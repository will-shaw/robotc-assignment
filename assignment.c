#pragma config(Sensor, S1,     Touch1,         sensorEV3_Touch)
#pragma config(Sensor, S2,     Touch2,         sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Tile Width: 95mm
Axel: { span: 120mm, circumference: 376.9mm, radius: 60mm)
Wheel { span: 55mm, circumference: 172.7mm, raduis: 27.5mm)
encoderCount = 360
*/
const int wheelCircum = 134;
const int speed = 50;
const int turnSpeed = 30;
const int tileWidth = 95;
const int laserOffset = 20;

const int reflectedBlack = 20;
const int correctionRadius = 150;
const int correctionDistance = 80;
const int correctionIncrement = 20;

string numbers[] = {"One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten"};

bool missionComplete = false;
bool isBlack = false;
bool objectDetected = false;
bool bumped = false;

int tileCount = 0;

float lengthToDegrees(float value) {
	return ((value / wheelCircum) * 360);
}

//float degreesToLength(float value) {
//	return (360 / (value * wheelCircum));
//}

float getTurnAngle(float adj) {
	return atan(correctionRadius/adj);
}

void lost() {
	playTone(780, 50);
	sleep(200);
	playTone(500, 60);
	sleep(200);
	playTone(300, 100);
}

void pivot(int direction) {
	setMotorSyncEncoder(leftMotor, rightMotor, direction * 100, 180, turnSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void pivot(int direction, int angle) {
	setMotorSyncEncoder(leftMotor, rightMotor, direction * 100, angle, turnSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void moveToTileEdge() {
	while(isBlack) {
		setMotorSync(leftMotor, rightMotor, 0, speed);
	}
}

void scanForObject() {
	pivot(-1);
	int totalPivot = 0;
	while (!objectDetected && totalPivot <= 360) {
		pivot(1, 30);
		totalPivot += 30;
	}
}

int correctiveMove() {
	int adjacent = 0;
	while(!isBlack && adjacent < correctionDistance) {
		setMotorSyncEncoder(leftMotor, rightMotor, 0, correctionIncrement, speed);
		adjacent += correctionIncrement;
		waitUntilMotorStop(leftMotor);
	}
	return adjacent;
}

bool correctiveRealign(int direction, float angle) {
	if (isBlack) {
		setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees((tileWidth/2) + laserOffset), speed);
		waitUntilMotorStop(leftMotor);
		pivot(direction, angle);
		return true;
	}
	return false;
}

/* If we expect a tile but don't find one; calculate correction */
void correction() {

	pivot(-1);
	int adjacent = correctiveMove();
	if (correctiveRealign(1, getTurnAngle(adjacent))) {
		return;
	}

	pivot(1, 360);
	setMotorSyncEncoder(leftMotor, rightMotor, 0, correctionDistance, speed);
	waitUntilMotorStop(leftMotor);

	adjacent = correctiveMove();
	if (correctiveRealign(-1, getTurnAngle(adjacent))) {
		return;
	}

	lost();
}

void push() {
	setMotorSyncEncoder(leftMotor,rightMotor, 0, 300, 100);
	waitUntilMotorStop(leftMotor);
}

task bumpCheck() {
	while (!missionComplete) {
		bumped = SensorValue[Touch1] || SensorValue[Touch2]; // may need updating to work.
	}
}

task sonarScan() {
	while (!missionComplete) {
		objectDetected = SensorValue[sonarSensor] < 600;
		displayCenteredBigTextLine(4, "Detected");
	}
}

task updateColour() {
	while (!missionComplete) {
		isBlack = SensorValue[Colour] <= reflectedBlack;
	}
}

/* Drive forward for a set number of wheel rotations. Then look for tower*/
task stageThree() {
	setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(1400), speed);
	waitUntilMotorStop(leftMotor);

	startTask(bumpCheck, 255);
	startTask(sonarScan, 255);
	scanForObject();

	while (!bumped) {
		if (objectDetected) {
			setMotorSync(leftMotor, rightMotor, 0, speed);
			} else {
			scanForObject();
		}
	}
	push();
	missionComplete = true;
}



/* Count 15 black tiles across the floor */
task stageTwo() {
	moveToTileEdge();
	bool newTile = true;

	while (tileCount < 15) {

		if (isBlack && newTile) {
			playTone(800, 30);
			newTile = false;
			tileCount++;
			displayCenteredBigTextLine(4, "%d", tileCount);
			moveToTileEdge();
		}

		setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(correctionRadius), speed);
		waitUntilMotorStop(leftMotor);

		if (!isBlack) {
			displayCenteredBigTextLine(4, "Correcting");
			correction();
			} else {
			newTile = true;
		}
	}

	pivot(1);
	startTask(stageThree,255);
}

/* Drive forward to black tile and pivot */
task stageOne() {

	while (isBlack) {
		setMotorSync(leftMotor, rightMotor, 0, speed);
	}

	while (!isBlack) {
		setMotorSync(leftMotor, rightMotor, 0, speed);
	}

	setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(tileWidth + laserOffset), speed);
	waitUntilMotorStop(leftMotor);
	pivot(1);
	startTask(stageTwo, 255);
}

task main()
{
	isBlack = true;
	setSoundVolume(100);

	startTask(updateColour, 255);

	startTask(stageOne, 255);

	while (!missionComplete) { }

	displayCenteredBigTextLine(4, "Mission Complete!");
	playTone(700, 100);
	sleep(100);
	playTone(1000, 200);
}
