#pragma config(Sensor, S1,     Touch1,         sensorEV3_Touch)
#pragma config(Sensor, S2,     Touch2,         sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Tile Width: 95mm
Axel: { span: 120mm, circumference: 376.9mm, radius: 60mm)
Wheel { span: 55mm, circumference: 172.7mm, raduis: 27.5mm)

*/

bool missionComplete = false;
bool isBlack = false;
bool objectDetected = false;
bool bumped = false;

int reflectedBlack = 20;

int wheelCircum = 134;
int speed = 50;
int turnSpeed = 30;
int tileCount = 0;
int tileWidth = 95;

int correctionDistance = 80; // 50 mm
int correctionRadius = 130; // 138 mm
int laserOffset = 20;

float lengthToDegrees(float value) {
	return ((value / wheelCircum) * 360);
}

void defeated() {
	playTone(780, 50);
	sleep(200);
	playTone(500, 60);
	sleep(200);
	playTone(300, 100);
}

void pivot(int direction) {
	setMotorSyncEncoder(leftMotor, rightMotor, direction * 100, 180, turnSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void pivot(int direction, int angle) {
	setMotorSyncEncoder(leftMotor, rightMotor, direction * 100, angle, turnSpeed);
	waitUntilMotorStop(leftMotor);
	waitUntilMotorStop(rightMotor);
}

void moveToTileEdge() {
	while(isBlack) {
		setMotorSync(leftMotor, rightMotor, 0, speed);
	}
}

void scanForObject() {
	pivot(-1);
	int totalPivot = 0;
	while (!objectDetected && totalPivot <= 360) {
		pivot(1, 30);
		totalPivot += 30;
	}
	pivot(1, 50);
}

/* If we expect a tile but don't find one; calculate correction */
void correction() {
	/* Turn 90 degrees left */
	pivot(-1);

	/* Drive a short distance and check for 'isBlack' */
	setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(correctionDistance), speed);
	waitUntilMotorStop(leftMotor);

	/* If black is found; drive 50% of tileWidth forward. Then rotate relative to the angle of inaccuracy in order to straighten up. */
	if (isBlack) {
		setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(tileWidth/2), speed);
		waitUntilMotorStop(leftMotor);
		pivot(1, radiansToDegrees(acos(correctionDistance / sqrt(pow((correctionDistance + (tileWidth /2)), 2) + pow(correctionRadius, 2)))));

		/* If black is not found here, rotate 360 degrees, then drive double the distance to check the other side */
		} else {
		pivot(1, 360);
		setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(correctionDistance) * 2, speed);
		waitUntilMotorStop(leftMotor);
		pivot(-1, radiansToDegrees(acos(correctionDistance / sqrt(pow((correctionDistance + (tileWidth /2)), 2) + pow(correctionRadius, 2)))));
	}
	/* Easily an edge case here if it hasn't been found, left or right side. We're screwed. It'll keep doing this until it finds anything black. */

	if (!isBlack) {
		defeated();
	}
}

void push() {
	setMotorSyncEncoder(leftMotor,rightMotor, 0, 300, 100);
	waitUntilMotorStop(leftMotor);
}

task bumpCheck() {
	while (!missionComplete) {
		bumped = SensorValue[Touch1] || SensorValue[Touch2]; // may need updating to work.
	}
}

task sonarScan() {
	while (!missionComplete) {
		objectDetected = SensorValue[sonarSensor] < 1000;
		if (objectDetected) {
			displayCenteredBigTextLine(4, "Detected");
		} else {
			displayCenteredBigTextLine(4, "");
		}
	}
}

task updateColour() {
	while (!missionComplete) {
		isBlack = SensorValue[Colour] <= reflectedBlack;
	}
}

/* Drive forward for a set number of wheel rotations. Then look for tower*/
task stageThree() {
	setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(1400), speed);
	waitUntilMotorStop(leftMotor);

	/* Begin scanning for tower, high priority; then rotate in increments until something is detected. */
	startTask(bumpCheck, 255);
	startTask(sonarScan, 255);
	scanForObject();

	/* Until we bump into the object, make corrections when we lose sight of it */
	while (!bumped) {
		if (objectDetected) {
			setMotorSync(leftMotor, rightMotor, 0, speed);
			} else {
			scanForObject();
		}
	}

	/* Since the object has been hit; push it off */
	push();
	missionComplete = true;
}

/* Count 15 black tiles across the floor */
task stageTwo() {
	/* Move until not black (tile edge). */
	moveToTileEdge();
	bool newTile = true;

	while (tileCount < 15) {

		/* If the current tile is black and new tile (has been previously no black) */
		if (isBlack && newTile) {
			tileCount++;
			playTone(784, 50);
			newTile = false;
			displayCenteredBigTextLine(4, "%d", tileCount);
			moveToTileEdge();
		}

		/* Otherwise, assume we've moved off black; drive to the edge of the correction radius. */	// Could be an egde case here where it's not a new tile so we drive double the distance.
		setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees(correctionRadius), speed);
		waitUntilMotorStop(leftMotor);


		/* Now check for black; if not, attempt correction. */
		if (!isBlack) {
			displayCenteredBigTextLine(4, "Correcting");
			correction();
			} else {
			newTile = true;
		}
	}

	/* Pivot; ready to start stage three */
	pivot(1);
	startTask(stageThree, 255);
}

/* Drive forward to black tile and pivot */
task stageOne() {
	/* Drive forward until we leave the black start tile. */
	while (isBlack) {
		setMotorSync(leftMotor, rightMotor, 0, speed);
	}

	/* Now drive forward until you hit the black tile. */
	while (!isBlack) {
		setMotorSync(leftMotor, rightMotor, 0, speed);
	}
	/* Once we find a black tile, drive forward appros 50% tile width .*/
	setMotorSyncEncoder(leftMotor, rightMotor, 0, lengthToDegrees((tileWidth/2) + laserOffset), speed);
	waitUntilMotorStop(leftMotor);

	/* Now pivot to the right. Then start stage 2 */
	pivot(1);
	playTone(800, 30);
	tileCount++;
	startTask(stageTwo, 255);
}


task main()
{
	/* calibrate the black colour from first tile */
	//black = SensorValue[Colour];
	isBlack = true;

	/* Start checking the colour and updating 'isBlack' */
	startTask(updateColour,255);

	/* start stage one, move off start tile and find stipe */
	startTask(stageOne, 255); // Start state one.

	/* Wait for a mission complete flag. Play tone and exit. */
	while (!missionComplete) { }

	displayCenteredBigTextLine(4, "Mission Complete!");
	playTone(700, 100);
	sleep(100);
	playTone(1000, 200);
}
